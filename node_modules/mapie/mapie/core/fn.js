const fs = require('fs');
var path = require('path');
const _ = require('lodash');

const setVar = globalVariable => {
    // Preload globals
    globalVariable.config = require(globalVariable.rootDir + '/config');
    
    globalVariable.packages = require('./packages')();

    
    
    globalVariable.services = require('./services')(globalVariable);
    globalVariable.middlewares = require('./middlewares')(globalVariable);
    globalVariable.Types = require('./types')(globalVariable);

    return globalVariable;
}

const getFiles = (rootDir, apiPath, pattern) => {

    const startPath = `${rootDir}/app/${apiPath}/`;
    const filter = new RegExp('\.' + pattern + '$', 'i');
    let routes = [];
    if (!fs.existsSync(startPath)) {
        // console.log(`path '${startPath}' does not exist'`)
        return [];
    }
    var files = fs.readdirSync(startPath);
    for (var i = 0; i < files.length; i++) {
        var filename = path.join(startPath, files[i]);
        var stat = fs.lstatSync(filename);
        if (stat.isDirectory()) {
            routes = [...routes, ...getFiles(rootDir, (rootDir? filename.replace(/\\/g, '/').replace(rootDir.replace(/\\/g, '/')+'/', ''): filename).replace(/\\/g, '/').replace(/^app\//, ''), pattern)];
        }
        else if (filename.match(filter)) {
            const fname = rootDir? filename.replace(/\\/g, '/').replace(rootDir.replace(/\\/g, '/')+'/', ''): filename;
            routes.push({
                name: files[i].replace('.' + pattern, ''),
                path: fname
            })
        };
    };
    return routes;
};

const defaultRoutes = handle => {
    return [
        {
            action: "POST",
            path: '/',
            resolve: handle.create
        },
        {
            action: 'GET',
            path: '/',
            resolve: handle.read
        },
        {
            action: 'GET',
            path: '/:id',
            resolve: handle.readOne
        },
        {
            action: 'PUT',
            path: '/:id',
            resolve: handle.update
        }
    ]
}

const defaultController = model => {
    return {
        async create(req) {
            return await new model(req.body).save();
        },
        async read(req) {
            return await model.find({}).then(data => data)
        },
        async readOne(req) {
            return await model.findById(req.params.id).then(data => {
                if (data) {
                    return data;
                } else {
                    return Promise.reject({
                        status: 404,
                        message: "Record not found"
                    })
                }
            })
        },
        async update(req) {
            return await model.findbyIdAndUpdate(req.params.id, req.body, { new: true })
        },
        // async delete(req) {}, 

    }
}

const mergeRoutes = (modelName, routeConfigFn, globalVariable, handle) => {


    const routeConfig = typeof routeConfigFn == 'function' ? routeConfigFn(handle) : (routeConfigFn || {});
    const model = globalVariable.models && globalVariable.models[routeConfig.options && routeConfig.options.targetModel ? routeConfig.options.targetModel : modelName];
    if (model && (!routeConfig.options || routeConfig.options.defaultRoutes == undefined || routeConfig.options.defaultRoutes)) {

        const dr = defaultRoutes({
            ...defaultController(model),
            ...handle
        })
        routeConfig.routes = [
            ...(routeConfig.routes || []).reduce((t, c) => {
                const ind = t.findIndex(e => (e.path == c.path && e.action == c.action));
                if (ind >= 0) {
                    t[ind] = {
                        ...t[ind],
                        ...c
                    }
                } else {
                    t = [c, ...t];
                }
                return t;
            }, dr)
        ];
    }
    routeConfig.routes = [
        ...routeConfig.routes,
        {
            path: '*',
            resolve: req => Promise.reject({
                status: 404,
                message: "Not found"
            })
        }
    ]
    return routeConfig;
}


module.exports = {
    getFiles, defaultController, mergeRoutes, setVar
}