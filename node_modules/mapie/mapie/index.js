const fs = require("fs");
const { pipeline } = require("stream");
const { getFiles, mergeRoutes, setVar } = require("./core/fn");
const routeResolver = require("./route-resolver");

const init = async (bootstrapLoc, globalVariable, options) => {
  globalVariable.rootDir =
    options && options.rootDir
      ? process.cwd() + "/" + options.rootDir
      : process.cwd();

  setVar(globalVariable);
  let bootstrap = null;
  if (!bootstrapLoc) {
    try {
      bootstrap = require(globalVariable.rootDir + "/bootstrap");
    } catch (err) {
      console.log("bootstrap.js missing at root");
      throw new Error(err);
    }
  } else {
    bootstrap = require(globalVariable.rootDir + bootstrapLoc);
  }

  const {
    before,
    apiGroups,
    after,
    appIntercept,
    routeOptions,
    logger,
    ...props
  } = bootstrap;

  // Logger config

  if (logger === null || logger === undefined) {
    globalVariable.log = (...args) => {
      console.log(...args);
    };
  } else if (!logger) {
    globalVariable.log = (...args) => {};
  } else if (typeof logger === "function") {
    globalVariable.log = logger;
  }

  if (props.db) {
    const { type, options, onSuccess, onError } = props.db;
    if (!type) {
      throw new Error("`db.type` is required");
    }
    if (!options) {
      throw new Error("`db.options` is required");
    }

    try {
      const connection = await require("./core/db")(props.db, globalVariable);

      if (connection) {
        if (onSuccess) {
          onSuccess(connection);
        }
      } else {
        const err = "Unknown error";
        if (onError) {
          onError(err);
        }
        console.log(err);
        throw new Error(err);
      }
    } catch (err) {
      if (onError) {
        onError(err);
      }
      console.log(err);
      throw new Error(err);
    }
  }

  // Server initializer
  const app = require("express")();
  if (!appIntercept) {
    appIntercept = (server) => server;
  }
  if (before) {
    for (let i = 0; i < before.length; i++) {
      app.use(before[i]);
    }
  }

  if (apiGroups) {
    for (let i = 0; i < apiGroups.length; i++) {
      app.use(
        apiGroups[i].path,
        ...(apiGroups[i].before || []),
        routeResolver()(
          ...getFiles(
            globalVariable.rootDir,
            apiGroups[i].apiGroupModule,
            "routes.js"
          ).map((e) => {
            const handleLoc = e.path.replace(
              e.name + ".routes.js",
              e.name + ".controller.js"
            );
            const handle = fs.existsSync(
              globalVariable.rootDir + "/" + handleLoc
            )
              ? require(globalVariable.rootDir + "/" + handleLoc)
              : {};
            const child = mergeRoutes(
              e.name,
              require(globalVariable.rootDir + "/" + e.path),
              globalVariable,
              handle
            );

            return {
              path: "/" + e.name,
              next: routeResolver({
                ...(routeOptions || {}),
                ...(apiGroups[i].options || {}),
                ...(child.options || {}),
              })(...(child.routes || [])),
            };
          })
        ),
        ...(apiGroups[i].after || [])
      );
    }
  }

  if (after) {
    for (let i = 0; i < after.length; i++) {
      app.use(after[i]);
    }
  }

  return appIntercept(app);

  return globalVariable;
};

module.exports = init;
